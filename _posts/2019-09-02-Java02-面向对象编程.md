---
layout:     post                   
title:      Java02面向对象编程
subtitle:   面向对象三大特征：封装、继承、多态   
date:       2019-09-02        
author:     HY                 
header-img: img/post-bg-2015.jpg
catalog: true                  
tags:                   
    - Java
    - 面向对象
---


# Java02: 面向对象编程

## 1 面向对象

这里的对象泛指现实中一切事物，每种事物都具备自己的**属性**和**行为**。
面向对象的语言中，包含了三大基本特征，即**封装、继承和多态**

### 1.1 类与对象

#### 类

类是一组相关属性和行为的集合，一类事物的模板，使用事物的**属性特征**和**行为特征**来描述该类事物。

类的定义格式：

```java
//成员变量：对应事物的属性  成员方法：对应事物的行为
public class ClassName {
    //成员变量
    String name;//姓名
    int age;//年龄
    //成员方法 
    publicvoid study() {
        System.out.println("好好学习，天天向上");
    }
}
```
注意：
> 没有`static`关键字


#### 对象/实例

对象是一类事物的具体体现，是类的一个实例，必然具备该类事物的属性和行为。

对象的使用

1. 导包
import 包名称.类名称
对于和当前类属于同一个包的情况下,可省略包语句
2. 创建: 必须用new操作符, 结果是一个引用类型
类名称 对象名 = new 类名称()
3. 使用
对象名.成员变量名
对象名.成员方法名(参数列表)

成员变量的默认值

- 基本类型
    - 整数（byte，short，int，long）:  0
    - 浮点数（ﬂoat，double）:  0.0
    - 字符（char）: '\u0000'
    - 布尔（boolean）: false
- 引用类型 
    - 数组，类，接口: null

#### 类与对象的关系

- 类是对一类事物的描述，是抽象的。
- 对象是一类事物的实例，是具体的。
- 类是对象的模板，对象是类的实体。


### 1.2 成员变量和局部变量区别

- 在类中的位置不同 重点
    - 成员变量：类中，方法外
    - 局部变量：方法中或者方法声明上(形式参数) 
- 作用范围不一样 重点
    - 成员变量：类中
    - 局部变量：方法中
- 初始化值的不同 重点
    - 成员变量：有默认值
    - 局部变量：**没有默认值。必须先定义，赋值，最后使用**
        - 参数在调用的时候必然会被赋值
- 在内存中的位置不同 了解
    - 成员变量：堆内存
    - 局部变量：栈内存
- 生命周期不同 了解
    - 成员变量：随着对象的创建而存在，随着对象的消失而消失
    - 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失


### 1.3 对象内存

#### 一个对象，调用一个方法
1. 类定义相关入方法区
2. 执行main:
    - main入栈
3. 定义对象:
    - 堆内存开辟,返回对象的地址值
    - 成员变量:在堆内生成变量并赋(默认)值
    - 成员方法:方法区类中成员方法的地址
4. 执行对象的方法:
    - 方法入栈
    - 沿地址找:对象地址(指向堆)->方法地址(指向方法区)
    - 执行完毕,出栈

#### 两个对象，调用同一个方法
- 对象的堆内地址不同,但都指向同一方法区类的方法

#### 两个引用指向同一个对象

- 两个引用的地址是相同的

#### 使用对象类型作为方法的参数

- 当一个对象作为参数,传递到方法当中时候,实际上传递的是**对象的地址值**

#### 使用对象类型作为方法的返回值

- 当一个对象类型作为方法的返回值时候,返回值是对象的地址值

## 2 封装

> 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。

### 2.1 封装的步骤

1. 使用 `private` 关键字来修饰成员变量。
格式: private 数据类型 变量名 ；   
2. 对需要访问的成员变量，提供对应的一对 `getXxx` 方法 、 `setXxx` 方法。

注意:
> `getXxx` 方法不能有参数, `setXxx` 方法不能有返回值



### 2.2 封装的优化

#### this 

当方法的局部变量和类的成员变量重名时,根据**就近原则**,优先使用局部变量,如果想访问成员变量,使用 `this` 关键字

this代表所在类的当前对象的引用（地址值）, 谁在调用, this就代表谁

格式: `this.成员变量名;`


#### 构造方法

当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。

定义格式:

    修饰符 构造方法名(参数列表){
        // 方法体
    }

注意:
> - 方法名与它所在的类名相同
> - 它没有返回值, 所以不需要返回值类型, 不需要void
> - 如果你不提供构造方法，系统会给出无参数构造方法。
> - 如果你提供了构造方法，系统将不再提供无参数构造方法。
> - 构造方法是可以**重载**的，既可以定义参数，也可以不定义参数。


### 2.3 标准代码——JavaBean

#### 要求

1. 所有的成员变量都要使用private关键字修饰
2. 为每一个成员变量编写一对Getter/Setter方法
3. 编写一个无参数的构造函方法
4. 编写一个全参数的构造方法

#### 自动生成代码

1. 选择 Code->Generate
2. 快捷键 Alt+Insert
3. 选择要自动生成的代码, 一般set和get放最后


## 3 继承




## 4 抽象类

## 5 接口

接口不是类，是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

### 5.1 接口定义基本格式

#### 如何定义一个接口的格式：

    public interface 接口名称 {
        // 接口内容
    }

> 备注：换成了关键字interface之后，编译生成的字节码文件仍然是：`.java` --> `.class`。

接口中可以包含的内容有：
1. 常量（Java 7）
2. 抽象方法（Java 7）`public abstract void method();`
abstract关键字可以省略，没有方法体。
该方法供子类实现使用。
3. 默认方法（Java 8）`public default void method() {}`
使用 `default` 修饰，不可省略，供子类调用或者子类重写。
4. 静态方法（Java 8）`public static void method2() {}`
使用 `static` 修饰，供接口直接调用。
5. 私有方法（Java 9）`private void method() {}`
使用 `private` 修饰，供接口中的默认方法或者静态方法调用。
5. 私有静态方法（Java 9）

>接口内部所有方法自动属于public, 因此public可以省略


### 5.2 接口的实现：
类与接口的关系为实现关系，即类实现接口，该类可以称为`接口的实现类`，也可以称为`接口的子类`。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements` 关键字。

1. 定义接口
2. 定义实现类：接口不能直接使用，必须有一个“实现类”来“实现”该接口。
格式：

    public class 实现类名称 implements 接口名称 {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【可选】
    }

接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
实现：去掉abstract关键字，加上方法体大括号。
> Tips: 可以通过ALT+ENTER导入重写的方法

3. 测试类中：创建**实现类**的对象，进行使用。
```java
public class Demo01Interface {
    public static void main(String[] args) {
        // 错误写法！不能直接new接口对象使用。
        // MyInterfaceAbstract inter = new MyInterfaceAbstract();

        // 创建实现类的对象使用
        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();
        impl.methodAbs1();
        impl.methodAbs2();
    }
}
```

>注意事项：
>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是**抽象类**。

#### 总结:
1. 成员变量其实是**常量**，格式：
[public] [static] [final] 数据类型 常量名称 = 数据值;
注意：
	常量必须进行赋值，而且一旦赋值不能改变。
	常量名称完全大写，用下划线进行分隔。

2. 接口中最重要的就是**抽象方法**，格式：
[public] [abstract] 返回值类型 方法名称(参数列表);
注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。

3. 从Java 8开始，接口里允许定义**默认方法**，格式：
[public] default 返回值类型 方法名称(参数列表) { 方法体 }
注意：默认方法可以继承也可以被覆盖重写,但是只能通过实现类的对象来调用

4. 从Java 8开始，接口里允许定义**静态方法**，格式：
[public] static 返回值类型 方法名称(参数列表) { 方法体 }
注意：静态与`.class`文件相关，只能通过接口名称进行调用，不能通过实现类的类名和实现类的对象来调用接口的静态方法

5. 从Java 9开始，接口里允许定义**私有方法**，格式：
普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }
静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }
如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。
注意：private的方法只有默认方法才能调用，private static方法只能静态方法能调用。


### 5.3 接口的多实现
在继承体系中，一个类只能继承一个父类。
对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。
一个类能继承一个父类，同时实现多个接口。
实现格式：

    class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {
        // 重写接口中抽象方法【必须】
        // 重写接口中默认方法【不重名时可选】
    }

对于重名方法:
1. 接口中，有多个**抽象方法**时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。
2. 接口中，有多个**默认方法**时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。

3. 接口中，存在同名的**静态方法**并不会冲突，原因是只能通过各自接口名访问静态方法。

优先级问题:
当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。


### 5.4 接口的多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。

1. 子接口重写默认方法时，default关键字可以保留。
2. 子类重写默认方法时，default关键字不可以保留。

> 其他注意事项:
> 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static ﬁnal修饰。
> 接口中，没有构造方法，不能创建对象。
> 接口中，没有静态代码块。

## 6 多态

`extends`继承或者`implements`实现是多态性的前提
> 优势:
> 实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。

### 6.1 多态的体现

1. 父类引用指向子类对象
2. 接口引用指向实现类对象

当使用上述多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，则执行子类重写后的方法。

> 访问成员变量的两种方式：
> 1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。
> 2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。


### 6.2 引用类型转换

#### 向上转型
父类引用指向一个子类对象时，便是**向上转型**。
`父类类型  变量名 = new 子类类型();`
#### 向下转型
父类类型向子类类型向下转换的过程，这个过程是强制的。
`子类类型 变量名 = (子类类型) 父类变量名;`
> Notes
> 向下转型是为了解决多态带来的问题,即不能调用子类拥有父类没有的方法

Java提供了`instanceof`关键字，给引用变量做类型的校验，格式如下：
`变量名 instanceof 数据类型 `



## 7 final 关键字

### 7.1 概述
ﬁnal： 不可改变。可以用于修饰类、方法和变量。
- 类：被修饰的类，不能被继承。
- 方法：被修饰的方法，不能被重写。
- 变量：被修饰的变量，不能被重新赋值。

### 7.2 使用

#### 修饰类
`修饰符 final class 类名 {}`
#### 修饰方法
`修饰符 final 返回值类型 方法名(参数列表){}`
> 重写被 `final` 修饰的方法，编译时就会报错。
#### 修饰变量
1. 局部变量——基本类型
基本类型的局部变量，被ﬁnal修饰后，只能赋值一次，不能再更改。
```java
for (int i = 0; i < 10; i++) {
    final int c = i;
    System.out.println(c);
}
```
> 上述代码可以通过编译, 每次循环，都是一次新的变量c。

2. 局部变量——引用类型
引用类型的局部变量，被ﬁnal修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改

3. 成员变量
使用final之后必须手动赋值, 直接赋值或者构造方法赋值二选一
使用构造方法赋值, 必须保证所有的重载构造方法都对final变量赋值

> 被ﬁnal修饰的常量名称，一般都有书写规范，所有字母都大写。


## 8 权限修饰符

### 8.1 概述

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限
- public：公共的。
- protected：受保护的
- default：默认的
- private：私有的

### 8.2 不同权限的访问能力

| |public| protected |default（空的）| private|
|-|   -  |     -     |     -         |-       |
|同一类中               |√ |√ |√ |√ |
|同一包中(子类与无关类) |√ |√ |√ |  |
|不同包的子类           |√ |√ |  |  |
|不同包中的无关类       |√ |  |  |  |

编写代码时，如果没有特殊的考虑，建议这样使用权限：
- 成员变量使用 private ，隐藏细节。
- 构造方法使用 public ，方便创建对象。
- 成员方法使用 public ，方便调用方法。
> 不加权限修饰符，其访问能力与default修饰符相同

## 9 内部类

### 9.1 概述

将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。

#### 成员内部类

定义在类中方法外的类

在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。

#### 访问特点

内部类可以直接访问外部类的成员，包括私有成员。
外部类要访问内部类的成员，必须要建立内部类的对象。
- 创建内部类对象格式：
`外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；`
- 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，`Person$Heart.class`



















